"""Coordinator Agent - Orchestrates multi-agent system."""

from typing import Any

from src.agents.base import BaseAgent, AgentResponse
from src.config.prompts import COORDINATOR_PROMPT
from src.observability.tracer import tracer
from src.models.trace import TraceEventType


# Routing tool schema
ROUTING_TOOL = {
    "name": "route_to_agent",
    "description": "Route the user's request to the appropriate specialist agent for handling.",
    "input_schema": {
        "type": "object",
        "properties": {
            "agent": {
                "type": "string",
                "enum": ["artist_discovery", "venue_matching", "booking_advisor"],
                "description": "The specialist agent to route to"
            },
            "reason": {
                "type": "string",
                "description": "Explanation of why this agent was chosen"
            },
            "refined_query": {
                "type": "string",
                "description": "Optional refined/clarified version of the user's query for the specialist"
            }
        },
        "required": ["agent", "reason"]
    }
}


class CoordinatorAgent(BaseAgent):
    """Coordinator agent that routes requests to specialist agents."""

    def __init__(self, client=None):
        """Initialize the coordinator agent."""
        super().__init__(
            name="coordinator",
            system_prompt=COORDINATOR_PROMPT,
            tools=[ROUTING_TOOL],
            client=client
        )
        self._specialist_agents: dict[str, BaseAgent] = {}

    def register_agent(self, name: str, agent: BaseAgent) -> None:
        """Register a specialist agent.

        Args:
            name: Name of the specialist agent
            agent: The agent instance
        """
        self._specialist_agents[name] = agent
        self.logger.info(f"Registered specialist agent: {name}", agent=name)

    def process(
        self,
        user_message: str,
        context: dict[str, Any] | None = None,
        conversation_history: list[dict[str, str]] | None = None
    ) -> AgentResponse:
        """Process a user message and route to appropriate specialist.

        Args:
            user_message: The user's query
            context: Optional context (preferences, etc.)
            conversation_history: Optional conversation history

        Returns:
            AgentResponse from the coordinator or routed specialist
        """
        tracer.record_event(
            TraceEventType.AGENT_START,
            self.name,
            {"query": user_message[:100]}
        )

        self.logger.info("Coordinator processing request", query_length=len(user_message))

        messages = self._build_messages(user_message, context, conversation_history)
        response, tokens_in, tokens_out = self._call_llm(messages)

        # Check if coordinator wants to route to a specialist
        tool_calls = self._extract_tool_calls(response)

        if tool_calls:
            # Extract routing decision
            routing = tool_calls[0]["input"]
            return self._execute_routing(
                routing,
                user_message,
                context,
                conversation_history,
                tokens_in,
                tokens_out
            )

        # No routing - coordinator responding directly
        tracer.record_event(
            TraceEventType.AGENT_END,
            self.name,
            {"response_type": "direct"}
        )

        self.logger.info("Coordinator responding directly")

        return AgentResponse(
            content=self._extract_text_response(response),
            tokens_in=tokens_in,
            tokens_out=tokens_out,
            metadata={"routed": False}
        )

    def _execute_routing(
        self,
        routing: dict[str, Any],
        original_message: str,
        context: dict[str, Any] | None,
        history: list[dict[str, str]] | None,
        coord_tokens_in: int,
        coord_tokens_out: int
    ) -> AgentResponse:
        """Execute a routing decision to a specialist agent.

        Args:
            routing: Routing decision with target agent and reason
            original_message: Original user message
            context: Optional context
            history: Optional conversation history
            coord_tokens_in: Tokens used by coordinator
            coord_tokens_out: Tokens generated by coordinator

        Returns:
            AgentResponse from the specialist agent
        """
        target = routing["agent"]
        reason = routing["reason"]
        query = routing.get("refined_query", original_message)

        tracer.record_event(
            TraceEventType.ROUTING_DECISION,
            self.name,
            {
                "target_agent": target,
                "reason": reason,
                "query_refined": query != original_message
            }
        )

        self.logger.info(
            f"Routing to {target}",
            target=target,
            reason=reason,
            refined=query != original_message
        )

        # Check if specialist is available
        if target not in self._specialist_agents:
            error_msg = f"Specialist agent '{target}' not available."
            self.logger.error(error_msg, target=target)

            tracer.record_event(
                TraceEventType.ERROR,
                self.name,
                {"error": error_msg, "target": target}
            )

            return AgentResponse(
                content=error_msg,
                tokens_in=coord_tokens_in,
                tokens_out=coord_tokens_out,
                metadata={"error": True, "target": target}
            )

        # Call the specialist agent
        specialist_response = self._specialist_agents[target].process(
            query,
            context,
            history
        )

        tracer.record_event(
            TraceEventType.AGENT_END,
            self.name,
            {
                "routed_to": target,
                "specialist_tokens": specialist_response.total_tokens
            }
        )

        self.logger.info(
            "Routing completed",
            target=target,
            total_tokens=coord_tokens_in + coord_tokens_out + specialist_response.total_tokens
        )

        # Combine token counts from coordinator and specialist
        return AgentResponse(
            content=specialist_response.content,
            tokens_in=coord_tokens_in + specialist_response.tokens_in,
            tokens_out=coord_tokens_out + specialist_response.tokens_out,
            metadata={
                "routed": True,
                "target_agent": target,
                "routing_reason": reason,
                "coordinator_tokens_in": coord_tokens_in,
                "coordinator_tokens_out": coord_tokens_out,
                "specialist_tokens_in": specialist_response.tokens_in,
                "specialist_tokens_out": specialist_response.tokens_out
            }
        )
